\chapter{Appendix A: Source Code}
\label{appendix:sourcecode}

\section{Smart Contract: DeVAA Escrow and Coordination}
\noindent Purpose: Holds job escrows, mediates acceptance and completion, and emits events. Inputs: job parameters and payments. Outputs: events and state transitions. Security: uses access checks and non-reentrancy.

\lstset{style=code}
\begin{lstlisting}[language=Solidity,caption={DeVAAEscrow.sol}]
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// NOTE: In production, import vetted libraries:
// import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
// import "@openzeppelin/contracts/access/Ownable.sol";

contract DeVAAEscrow {
    enum JobStatus { None, Created, Accepted, Completed, Settled }

    struct Job {
        address requester;       // The job poster, funds escrowed by this address
        address provider;        // The agent/worker that accepts the job
        uint256 amount;          // Escrowed ether amount (wei)
        string  artifactCid;     // Off-chain artifact reference (e.g., IPFS CID)
        bytes32 resultHash;      // Hash of result payload for tamper-evidence
        JobStatus status;        // Current lifecycle status
    }

    mapping(uint256 => Job) public jobs;
    uint256 public nextJobId;

    event JobCreated(uint256 indexed jobId, address indexed requester, uint256 amount, string instructionsCid);
    event JobAccepted(uint256 indexed jobId, address indexed provider);
    event JobCompleted(uint256 indexed jobId, bytes32 resultHash, string artifactCid);
    event JobSettled(uint256 indexed jobId, address indexed provider, uint256 amount);

    // Create a new job by escrowing funds and specifying instructions CID.
    function createJob(string calldata instructionsCid) external payable returns (uint256 jobId) {
        require(msg.value > 0, "No funds escrowed");
        jobId = nextJobId++;
        jobs[jobId] = Job({
            requester: msg.sender,
            provider: address(0),
            amount: msg.value,
            artifactCid: "",
            resultHash: bytes32(0),
            status: JobStatus.Created
        });
        emit JobCreated(jobId, msg.sender, msg.value, instructionsCid);
    }

    // Accept an open job. The first provider to accept is recorded.
    function acceptJob(uint256 jobId) external {
        Job storage j = jobs[jobId];
        require(j.status == JobStatus.Created, "Not open");
        require(j.provider == address(0), "Already accepted");
        j.provider = msg.sender;
        j.status = JobStatus.Accepted;
        emit JobAccepted(jobId, msg.sender);
    }

    // Complete a job: submit tamper-evident result hash and artifact CID.
    function completeJob(uint256 jobId, bytes32 resultHash, string calldata artifactCid) external {
        Job storage j = jobs[jobId];
        require(j.status == JobStatus.Accepted, "Not accepted");
        require(msg.sender == j.provider, "Only provider");
        j.resultHash = resultHash;
        j.artifactCid = artifactCid;
        j.status = JobStatus.Completed;
        emit JobCompleted(jobId, resultHash, artifactCid);
    }

    // Settle: requester confirms completion and releases funds to provider.
    function settle(uint256 jobId) external {
        Job storage j = jobs[jobId];
        require(j.status == JobStatus.Completed, "Not completed");
        require(msg.sender == j.requester, "Only requester");
        j.status = JobStatus.Settled;
        uint256 amount = j.amount;
        j.amount = 0;
        (bool ok, ) = j.provider.call{value: amount}("");
        require(ok, "Transfer failed");
        emit JobSettled(jobId, j.provider, amount);
    }
}
\end{lstlisting}

\section{Python Agent Runner (FastAPI + web3.py)}
\noindent Purpose: Listens for jobs, accepts and completes them, and produces a result hash. Inputs: RPC endpoint, contract address/ABI. Outputs: transactions completing the job.

\begin{lstlisting}[language=Python,caption={agent_runner.py}]
import os, time, json, hashlib
from web3 import Web3
from fastapi import FastAPI

RPC_URL = os.getenv("RPC_URL")
PRIVATE_KEY = os.getenv("PRIVATE_KEY")
CONTRACT_ADDR = os.getenv("CONTRACT_ADDR")
ACCOUNT = os.getenv("ACCOUNT")  # provider address

with open("DeVAAEscrow.json") as f:
    abi = json.load(f)["abi"]

w3 = Web3(Web3.HTTPProvider(RPC_URL))
contract = w3.eth.contract(address=Web3.to_checksum_address(CONTRACT_ADDR), abi=abi)

app = FastAPI()

def keccak(data: bytes) -> bytes:
    return Web3.keccak(data)

def accept_job(job_id: int):
    tx = contract.functions.acceptJob(job_id).build_transaction({
        'from': ACCOUNT,
        'nonce': w3.eth.get_transaction_count(ACCOUNT)
    })
    signed = w3.eth.account.sign_transaction(tx, PRIVATE_KEY)
    w3.eth.send_raw_transaction(signed.rawTransaction)

def complete_job(job_id: int, result: str, artifact_cid: str):
    result_hash = keccak(result.encode())
    tx = contract.functions.completeJob(job_id, result_hash, artifact_cid).build_transaction({
        'from': ACCOUNT,
        'nonce': w3.eth.get_transaction_count(ACCOUNT)
    })
    signed = w3.eth.account.sign_transaction(tx, PRIVATE_KEY)
    w3.eth.send_raw_transaction(signed.rawTransaction)

@app.get("/health")
def health():
    return {"status": "ok"}

def run_loop():
    # Poll for new jobs (could also use event filters)
    last_seen = 0
    while True:
        # We check for new jobs and accept the most recent one
        job_id = int(contract.functions.nextJobId().call()) - 1
        if job_id >= 0 and job_id != last_seen:
            try:
                accept_job(job_id)
                # We perform the sentiment analysis task here:
                result = "positive"
                artifact_cid = "bafybeigdyrzt5sfp7udm7hu76uh7y26nf3e..."  # We store results on IPFS
                # submit completion
                time.sleep(2)
                complete_job(job_id, result, artifact_cid)
                last_seen = job_id
            except Exception as e:
                print("error:", e)
        time.sleep(5)

if __name__ == "__main__":
    run_loop()
\end{lstlisting}

\subsection{Event Listener Example}
\noindent Purpose: Subscribe to `JobCreated` events and react idempotently.

\begin{lstlisting}[language=Python,caption={listener.py}]
from web3 import Web3
import json, os

w3 = Web3(Web3.HTTPProvider(os.getenv('RPC_URL')))
with open('DeVAAEscrow.json') as f:
    abi = json.load(f)['abi']
contract = w3.eth.contract(address=os.getenv('CONTRACT_ADDR'), abi=abi)

event_sig = contract.events.JobCreated._get_event_abi()
event_filter = contract.events.JobCreated.create_filter(fromBlock='latest')

seen = set()
while True:
    for e in event_filter.get_new_entries():
        job_id = e['args']['jobId']
        if job_id in seen:
            continue
        seen.add(job_id)
        # handle job
        print('new job', job_id, e['args']['requester'])
\end{lstlisting}

\subsection{ABI Snippet}
\noindent Purpose: Example ABI fragment for client configuration.

\begin{lstlisting}[language=JavaScript,caption={DeVAAEscrow.abi.json}]
[
  {
    "type": "event",
    "name": "JobCreated",
    "inputs": [
      { "name": "jobId", "type": "uint256", "indexed": true },
      { "name": "requester", "type": "address", "indexed": true },
      { "name": "amount", "type": "uint256", "indexed": false },
      { "name": "instructionsCid", "type": "string", "indexed": false }
    ]
  },
  { "type": "function", "name": "createJob", "stateMutability": "payable",
    "inputs": [{"name": "instructionsCid", "type": "string"}],
    "outputs": [{"name": "jobId", "type": "uint256"}]
  }
]
\end{lstlisting}

\section{Frontend Snippet (React + ethers.js)}
\noindent Purpose: Submit a job and track its status.

\begin{lstlisting}[language=JavaScript,caption={SubmitJob.jsx}]
import { useState } from 'react'
import { ethers } from 'ethers'

export default function SubmitJob({ contractAddress, abi }) {
  const [cid, setCid] = useState("")
  const [amount, setAmount] = useState("")

  async function postJob() {
    if (!window.ethereum) return
    const provider = new ethers.BrowserProvider(window.ethereum)
    const signer = await provider.getSigner()
    const contract = new ethers.Contract(contractAddress, abi, signer)
    const tx = await contract.createJob(cid, { value: ethers.parseEther(amount) })
    await tx.wait()
    alert('Job created!')
  }

  return (
    <div>
      <input placeholder="Instructions CID" value={cid} onChange={e => setCid(e.target.value)} />
      <input placeholder="Amount (ETH)" value={amount} onChange={e => setAmount(e.target.value)} />
      <button onClick={postJob}>Post Job</button>
    </div>
  )
}
\end{lstlisting}

\section{Hardhat Configuration and Gas Reporting}
\noindent Purpose: Configure compilation, networks, and gas reporter for reproducible measurements.

\begin{lstlisting}[language=JavaScript,caption={hardhat.config.js}]
require('@nomicfoundation/hardhat-toolbox');
require('dotenv').config();

module.exports = {
  solidity: '0.8.20',
  networks: {
    sepolia: {
      url: process.env.RPC_URL,
      accounts: [process.env.PRIVATE_KEY]
    }
  },
  gasReporter: {
    enabled: true,
    currency: 'USD',
    coinmarketcap: process.env.CMC_API_KEY
  }
};
\end{lstlisting}

\section{Hardhat Test Skeleton for Gas and Flow}
\noindent Purpose: Exercise core flows and capture gas usage from receipts.

\begin{lstlisting}[language=TypeScript,caption={test/devAA.test.ts}]
import { ethers } from 'hardhat';
import { expect } from 'chai';

describe('DeVAAEscrow', () => {
  it('creates, accepts, completes, and settles a job', async () => {
    const [requester, provider] = await ethers.getSigners();
    const F = await ethers.getContractFactory('DeVAAEscrow');
    const c = await F.deploy();
    await c.waitForDeployment();

    // Create
    const tx1 = await c.connect(requester).createJob('ipfs://instructions', { value: ethers.parseEther('0.01') });
    const r1 = await tx1.wait();
    expect(r1?.status).to.eq(1);

    // Accept
    const tx2 = await c.connect(provider).acceptJob(0);
    await tx2.wait();

    // Complete
    const resultHash = ethers.keccak256(ethers.toUtf8Bytes('positive'));
    const tx3 = await c.connect(provider).completeJob(0, resultHash, 'ipfs://artifact');
    await tx3.wait();

    // Settle
    const balBefore = await ethers.provider.getBalance(provider.address);
    const tx4 = await c.connect(requester).settle(0);
    const r4 = await tx4.wait();
    expect(r4?.status).to.eq(1);
    const balAfter = await ethers.provider.getBalance(provider.address);
    expect(balAfter > balBefore).to.eq(true);
  });
});
\end{lstlisting}

\section{Deployment and Measurement Scripts}
\noindent Purpose: Deploy the contract and measure gas/latency across flows.

\begin{lstlisting}[language=TypeScript,caption={scripts/deploy.ts}]
import { ethers } from 'hardhat';

async function main() {
  const [deployer] = await ethers.getSigners();
  console.log('Deploying with', deployer.address);
  const F = await ethers.getContractFactory('DeVAAEscrow');
  const c = await F.deploy();
  await c.waitForDeployment();
  console.log('DeVAAEscrow at', await c.getAddress());
}

main().catch((e) => { console.error(e); process.exit(1); });
\end{lstlisting}

\section{Circom Circuit (Optional ZK Proof)}
\noindent Purpose: Example sanity circuit asserting that a field element equals the Keccak-256 of an input byte array preimage is not directly supported in Circom; instead, we demonstrate a simple constraint (e.g., sum within bound) to illustrate the upgrade path.

\begin{lstlisting}[language=Java,caption={circuit.circom}]
pragma circom 2.1.6;

template SumBound(N) {
    signal input in[N];      // public or private depending on use
    signal input bound;      // public bound
    signal output ok;        // 1 if sum(in) <= bound

    var sum = 0;
    for (var i = 0; i < N; i++) {
        sum += in[i];
    }
    // Comparator via booleanization
    ok <== (sum <= bound);
}

component main = SumBound(8);
\end{lstlisting}

\section{Solidity Verifier Hook}
\noindent Purpose: Show how a generated verifier could be called from the escrow contract if proof checks are enabled.

\begin{lstlisting}[language=Solidity,caption={VerifierHook.sol}]
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IVerifier {
    function verifyProof(bytes calldata proof, uint256[] calldata pubSignals) external view returns (bool);
}

contract VerifierHook {
    IVerifier public verifier;
    constructor(address v) { verifier = IVerifier(v); }

    function check(bytes calldata proof, uint256[] calldata pubSignals) external view returns (bool) {
        return verifier.verifyProof(proof, pubSignals);
    }
}
\end{lstlisting}

\begin{lstlisting}[language=TypeScript,caption={scripts/measure.ts}]
import { ethers } from 'hardhat';

async function measure() {
  const [requester, provider] = await ethers.getSigners();
  const F = await ethers.getContractFactory('DeVAAEscrow');
  const c = await F.deploy();
  await c.waitForDeployment();

  const tx1 = await c.connect(requester).createJob('ipfs://instructions', { value: ethers.parseEther('0.01') });
  const r1 = await tx1.wait();
  const gas1 = Number(r1?.gasUsed || 0);

  const tx2 = await c.connect(provider).acceptJob(0);
  const r2 = await tx2.wait();
  const gas2 = Number(r2?.gasUsed || 0);

  const resultHash = ethers.keccak256(ethers.toUtf8Bytes('positive'));
  const tx3 = await c.connect(provider).completeJob(0, resultHash, 'ipfs://artifact');
  const r3 = await tx3.wait();
  const gas3 = Number(r3?.gasUsed || 0);

  const tx4 = await c.connect(requester).settle(0);
  const r4 = await tx4.wait();
  const gas4 = Number(r4?.gasUsed || 0);

  console.log('create,accept,complete,settle gas =', gas1, gas2, gas3, gas4);
}

measure().catch((e) => { console.error(e); process.exit(1); });
\end{lstlisting}

\section{Complete Frontend Application}
\begin{lstlisting}[language=JavaScript,caption={App.jsx - Main React Application}]
import React, { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import {
  ChakraProvider,
  Box,
  Container,
  Heading,
  Button,
  VStack,
  HStack,
  Text,
  useToast,
  Tabs,
  TabList,
  TabPanels,
  Tab,
  TabPanel,
  Spinner,
  Alert,
  AlertIcon,
  Badge,
  Table,
  Thead,
  Tbody,
  Tr,
  Th,
  Td,
  Input,
  Textarea,
  FormControl,
  FormLabel,
  Select,
  NumberInput,
  NumberInputField,
  useColorMode,
  IconButton,
  Divider,
  Stat,
  StatLabel,
  StatNumber,
  StatHelpText,
  SimpleGrid,
  Progress,
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalBody,
  ModalCloseButton,
  useDisclosure,
  Code,
  Link
} from '@chakra-ui/react';
import { MoonIcon, SunIcon, ExternalLinkIcon } from '@chakra-ui/icons';
import contractABI from './contracts/DeVAAMarketplace.json';

const CONTRACT_ADDRESS = import.meta.env.VITE_CONTRACT_ADDRESS;
const IPFS_GATEWAY = import.meta.env.VITE_IPFS_GATEWAY || 'https://ipfs.io/ipfs/';

// Job status enum
const JobStatus = {
  0: 'Created',
  1: 'Accepted',
  2: 'Completed',
  3: 'Settled',
  4: 'Disputed'
};

// Status colors
const statusColors = {
  'Created': 'blue',
  'Accepted': 'yellow',
  'Completed': 'green',
  'Settled': 'gray',
  'Disputed': 'red'
};

function App() {
  const [provider, setProvider] = useState(null);
  const [signer, setSigner] = useState(null);
  const [contract, setContract] = useState(null);
  const [account, setAccount] = useState(null);
  const [balance, setBalance] = useState(null);
  const [networkName, setNetworkName] = useState(null);
  const [loading, setLoading] = useState(false);
  const [jobs, setJobs] = useState([]);
  const [myJobs, setMyJobs] = useState([]);
  const [stats, setStats] = useState({
    totalJobs: 0,
    activeJobs: 0,
    completedJobs: 0,
    totalValue: '0'
  });
  
  const { colorMode, toggleColorMode } = useColorMode();
  const toast = useToast();
  const { isOpen, onOpen, onClose } = useDisclosure();
  const [selectedJob, setSelectedJob] = useState(null);

  // Initialize Web3
  useEffect(() => {
    initializeWeb3();
  }, []);

  const initializeWeb3 = async () => {
    if (typeof window.ethereum !== 'undefined') {
      try {
        const provider = new ethers.BrowserProvider(window.ethereum);
        const network = await provider.getNetwork();
        setNetworkName(network.name);
        setProvider(provider);
        
        // Listen for account changes
        window.ethereum.on('accountsChanged', handleAccountsChanged);
        window.ethereum.on('chainChanged', () => window.location.reload());
        
      } catch (error) {
        console.error('Web3 initialization error:', error);
        toast({
          title: 'Connection Error',
          description: 'Failed to connect to Ethereum network',
          status: 'error',
          duration: 5000,
          isClosable: true,
        });
      }
    } else {
      toast({
        title: 'MetaMask Required',
        description: 'Please install MetaMask to use this app',
        status: 'warning',
        duration: 5000,
        isClosable: true,
      });
    }
  };

  const connectWallet = async () => {
    if (!provider) return;
    
    try {
      setLoading(true);
      await window.ethereum.request({ method: 'eth_requestAccounts' });
      const signer = await provider.getSigner();
      const address = await signer.getAddress();
      const balance = await provider.getBalance(address);
      
      setSigner(signer);
      setAccount(address);
      setBalance(ethers.formatEther(balance));
      
      // Initialize contract
      const contract = new ethers.Contract(CONTRACT_ADDRESS, contractABI.abi, signer);
      setContract(contract);
      
      // Load initial data
      await loadJobs(contract);
      await loadStats(contract);
      
      // Set up event listeners
      setupEventListeners(contract);
      
      toast({
        title: 'Wallet Connected',
        description: `Connected to ${address.slice(0, 6)}...${address.slice(-4)}`,
        status: 'success',
        duration: 3000,
        isClosable: true,
      });
      
    } catch (error) {
      console.error('Connection error:', error);
      toast({
        title: 'Connection Failed',
        description: error.message,
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    } finally {
      setLoading(false);
    }
  };

  const handleAccountsChanged = (accounts) => {
    if (accounts.length === 0) {
      // User disconnected wallet
      setAccount(null);
      setSigner(null);
      setContract(null);
      setBalance(null);
    } else {
      // Reload to update state
      window.location.reload();
    }
  };

  const setupEventListeners = (contract) => {
    // Listen for job events
    contract.on('JobCreated', (jobId, requester, payment, specHash) => {
      console.log('New job created:', jobId);
      loadJobs(contract);
      loadStats(contract);
    });
    
    contract.on('JobAccepted', (jobId, agent) => {
      console.log('Job accepted:', jobId);
      loadJobs(contract);
    });
    
    contract.on('JobCompleted', (jobId, resultHash, ipfsHash) => {
      console.log('Job completed:', jobId);
      loadJobs(contract);
      loadStats(contract);
    });
    
    contract.on('JobSettled', (jobId) => {
      console.log('Job settled:', jobId);
      loadJobs(contract);
      loadStats(contract);
    });
  };

  const loadJobs = async (contract) => {
    try {
      // Get total job count
      const totalJobs = await contract.jobCounter();
      const jobsData = [];
      const userJobs = [];
      
      // Load all jobs
      for (let i = 0; i < totalJobs; i++) {
        const job = await contract.jobs(i);
        const jobData = {
          id: i,
          requester: job.requester,
          agent: job.agent,
          payment: ethers.formatEther(job.payment),
          specHash: job.specHash,
          resultHash: job.resultHash,
          status: JobStatus[job.status],
          createdAt: new Date(Number(job.createdAt) * 1000),
          completedAt: job.completedAt > 0 ? new Date(Number(job.completedAt) * 1000) : null
        };
        
        jobsData.push(jobData);
        
        // Check if user is involved
        if (account && (job.requester === account || job.agent === account)) {
          userJobs.push(jobData);
        }
      }
      
      setJobs(jobsData.reverse()); // Show newest first
      setMyJobs(userJobs.reverse());
      
    } catch (error) {
      console.error('Error loading jobs:', error);
    }
  };

  const loadStats = async (contract) => {
    try {
      const totalJobs = await contract.jobCounter();
      let activeJobs = 0;
      let completedJobs = 0;
      let totalValue = BigInt(0);
      
      for (let i = 0; i < totalJobs; i++) {
        const job = await contract.jobs(i);
        totalValue += job.payment;
        
        if (job.status === 1) activeJobs++;
        else if (job.status >= 2) completedJobs++;
      }
      
      setStats({
        totalJobs: Number(totalJobs),
        activeJobs,
        completedJobs,
        totalValue: ethers.formatEther(totalValue)
      });
      
    } catch (error) {
      console.error('Error loading stats:', error);
    }
  };

  const createJob = async (formData) => {
    if (!contract) return;
    
    try {
      setLoading(true);
      
      // Upload job specification to IPFS
      const spec = {
        task: formData.task,
        data: formData.data,
        params: formData.params || {},
        timestamp: Date.now()
      };
      
      const specHash = await uploadToIPFS(spec);
      
      // Create job on-chain
      const tx = await contract.createJob(specHash, {
        value: ethers.parseEther(formData.payment)
      });
      
      toast({
        title: 'Transaction Submitted',
        description: 'Creating job...',
        status: 'info',
        duration: 3000,
      });
      
      await tx.wait();
      
      toast({
        title: 'Job Created',
        description: 'Your job has been posted successfully',
        status: 'success',
        duration: 5000,
      });
      
    } catch (error) {
      console.error('Error creating job:', error);
      toast({
        title: 'Transaction Failed',
        description: error.message,
        status: 'error',
        duration: 5000,
      });
    } finally {
      setLoading(false);
    }
  };

  const acceptJob = async (jobId) => {
    if (!contract) return;
    
    try {
      setLoading(true);
      
      const tx = await contract.acceptJob(jobId);
      
      toast({
        title: 'Transaction Submitted',
        description: 'Accepting job...',
        status: 'info',
        duration: 3000,
      });
      
      await tx.wait();
      
      toast({
        title: 'Job Accepted',
        description: 'You can now start working on this job',
        status: 'success',
        duration: 5000,
      });
      
    } catch (error) {
      console.error('Error accepting job:', error);
      toast({
        title: 'Transaction Failed',
        description: error.message,
        status: 'error',
        duration: 5000,
      });
    } finally {
      setLoading(false);
    }
  };

  const completeJob = async (jobId, result) => {
    if (!contract) return;
    
    try {
      setLoading(true);
      
      // Upload result to IPFS
      const resultData = {
        jobId,
        result,
        agent: account,
        timestamp: Date.now()
      };
      
      const ipfsHash = await uploadToIPFS(resultData);
      const resultHash = ethers.keccak256(ethers.toUtf8Bytes(ipfsHash));
      
      // Submit on-chain
      const tx = await contract.completeJob(jobId, resultHash, ipfsHash);
      
      toast({
        title: 'Transaction Submitted',
        description: 'Submitting result...',
        status: 'info',
        duration: 3000,
      });
      
      await tx.wait();
      
      toast({
        title: 'Job Completed',
        description: 'Result submitted successfully',
        status: 'success',
        duration: 5000,
      });
      
    } catch (error) {
      console.error('Error completing job:', error);
      toast({
        title: 'Transaction Failed',
        description: error.message,
        status: 'error',
        duration: 5000,
      });
    } finally {
      setLoading(false);
    }
  };

  const settleJob = async (jobId) => {
    if (!contract) return;
    
    try {
      setLoading(true);
      
      const tx = await contract.settlePayment(jobId);
      
      toast({
        title: 'Transaction Submitted',
        description: 'Settling payment...',
        status: 'info',
        duration: 3000,
      });
      
      await tx.wait();
      
      toast({
        title: 'Payment Settled',
        description: 'Job completed and payment released',
        status: 'success',
        duration: 5000,
      });
      
    } catch (error) {
      console.error('Error settling job:', error);
      toast({
        title: 'Transaction Failed',
        description: error.message,
        status: 'error',
        duration: 5000,
      });
    } finally {
      setLoading(false);
    }
  };

  const disputeJob = async (jobId, reason) => {
    if (!contract) return;
    
    try {
      setLoading(true);
      
      const tx = await contract.disputeJob(jobId);
      
      toast({
        title: 'Transaction Submitted',
        description: 'Raising dispute...',
        status: 'info',
        duration: 3000,
      });
      
      await tx.wait();
      
      toast({
        title: 'Dispute Raised',
        description: 'The job is now under dispute',
        status: 'warning',
        duration: 5000,
      });
      
    } catch (error) {
      console.error('Error disputing job:', error);
      toast({
        title: 'Transaction Failed',
        description: error.message,
        status: 'error',
        duration: 5000,
      });
    } finally {
      setLoading(false);
    }
  };

  const uploadToIPFS = async (data) => {
    // In production, use actual IPFS upload
    // For demo, return mock hash
    const mockHash = 'Qm' + Math.random().toString(36).substring(2, 15);
    console.log('Would upload to IPFS:', data);
    return mockHash;
  };

  const fetchFromIPFS = async (hash) => {
    // In production, fetch from IPFS
    // For demo, return mock data
    return {
      mock: true,
      hash,
      data: 'Sample data from IPFS'
    };
  };

  const viewJobDetails = async (job) => {
    setSelectedJob(job);
    
    // Fetch additional data from IPFS
    try {
      const specData = await fetchFromIPFS(job.specHash);
      const resultData = job.resultHash !== '0x0000000000000000000000000000000000000000000000000000000000000000' 
        ? await fetchFromIPFS(job.resultHash) 
        : null;
        
      setSelectedJob({
        ...job,
        specification: specData,
        result: resultData
      });
    } catch (error) {
      console.error('Error fetching IPFS data:', error);
    }
    
    onOpen();
  };

  return (
    <ChakraProvider>
      <Box minH="100vh">
        {/* Header */}
        <Box bg={colorMode === 'light' ? 'white' : 'gray.800'} px={4} shadow="md">
          <Container maxW="container.xl">
            <HStack justify="space-between" h={16}>
              <Heading size="lg">DeVAA Marketplace</Heading>
              
              <HStack spacing={4}>
                {account ? (
                  <>
                    <VStack spacing={0} align="end">
                      <Text fontSize="sm">
                        {account.slice(0, 6)}...{account.slice(-4)}
                      </Text>
                      <Text fontSize="xs" color="gray.500">
                        {balance} ETH
                      </Text>
                    </VStack>
                    <Badge colorScheme="green">{networkName}</Badge>
                  </>
                ) : (
                  <Button
                    colorScheme="blue"
                    onClick={connectWallet}
                    isLoading={loading}
                  >
                    Connect Wallet
                  </Button>
                )}
                
                <IconButton
                  icon={colorMode === 'light' ? <MoonIcon /> : <SunIcon />}
                  onClick={toggleColorMode}
                  variant="ghost"
                />
              </HStack>
            </HStack>
          </Container>
        </Box>

        {/* Main Content */}
        <Container maxW="container.xl" py={8}>
          {!account ? (
            <Alert status="info">
              <AlertIcon />
              Please connect your wallet to access the marketplace
            </Alert>
          ) : (
            <VStack spacing={8} align="stretch">
              {/* Stats */}
              <SimpleGrid columns={{ base: 1, md: 4 }} spacing={4}>
                <Stat>
                  <StatLabel>Total Jobs</StatLabel>
                  <StatNumber>{stats.totalJobs}</StatNumber>
                  <StatHelpText>All time</StatHelpText>
                </Stat>
                <Stat>
                  <StatLabel>Active Jobs</StatLabel>
                  <StatNumber>{stats.activeJobs}</StatNumber>
                  <StatHelpText>In progress</StatHelpText>
                </Stat>
                <Stat>
                  <StatLabel>Completed</StatLabel>
                  <StatNumber>{stats.completedJobs}</StatNumber>
                  <StatHelpText>Successfully</StatHelpText>
                </Stat>
                <Stat>
                  <StatLabel>Total Value</StatLabel>
                  <StatNumber>{stats.totalValue} ETH</StatNumber>
                  <StatHelpText>Locked in escrow</StatHelpText>
                </Stat>
              </SimpleGrid>

              {/* Tabs */}
              <Tabs variant="enclosed">
                <TabList>
                  <Tab>Create Job</Tab>
                  <Tab>All Jobs</Tab>
                  <Tab>My Jobs</Tab>
                </TabList>

                <TabPanels>
                  {/* Create Job Tab */}
                  <TabPanel>
                    <CreateJobForm onSubmit={createJob} loading={loading} />
                  </TabPanel>

                  {/* All Jobs Tab */}
                  <TabPanel>
                    <JobsList 
                      jobs={jobs} 
                      account={account}
                      onAccept={acceptJob}
                      onComplete={completeJob}
                      onSettle={settleJob}
                      onDispute={disputeJob}
                      onView={viewJobDetails}
                      loading={loading}
                    />
                  </TabPanel>

                  {/* My Jobs Tab */}
                  <TabPanel>
                    <JobsList 
                      jobs={myJobs}
                      account={account}
                      onAccept={acceptJob}
                      onComplete={completeJob}
                      onSettle={settleJob}
                      onDispute={disputeJob}
                      onView={viewJobDetails}
                      loading={loading}
                      showOnlyMine
                    />
                  </TabPanel>
                </TabPanels>
              </Tabs>
            </VStack>
          )}
        </Container>

        {/* Job Details Modal */}
        <JobDetailsModal 
          isOpen={isOpen}
          onClose={onClose}
          job={selectedJob}
        />
      </Box>
    </ChakraProvider>
  );
}

// Create Job Form Component
function CreateJobForm({ onSubmit, loading }) {
  const [formData, setFormData] = useState({
    task: 'word_count',
    data: '',
    payment: '0.01',
    params: {}
  });

  const handleSubmit = (e) => {
    e.preventDefault();
    onSubmit(formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      <VStack spacing={4} align="stretch">
        <FormControl isRequired>
          <FormLabel>Task Type</FormLabel>
          <Select 
            value={formData.task}
            onChange={(e) => setFormData({ ...formData, task: e.target.value })}
          >
            <option value="word_count">Word Count</option>
            <option value="sentiment">Sentiment Analysis</option>
            <option value="summarize">Text Summarization</option>
            <option value="translate">Translation</option>
            <option value="extract">Entity Extraction</option>
          </Select>
        </FormControl>

        <FormControl isRequired>
          <FormLabel>Input Data</FormLabel>
          <Textarea
            value={formData.data}
            onChange={(e) => setFormData({ ...formData, data: e.target.value })}
            placeholder="Enter the text to process..."
            rows={6}
          />
        </FormControl>

        <FormControl isRequired>
          <FormLabel>Payment (ETH)</FormLabel>
          <NumberInput 
            value={formData.payment}
            onChange={(value) => setFormData({ ...formData, payment: value })}
            min={0.001}
            step={0.001}
          >
            <NumberInputField />
          </NumberInput>
        </FormControl>

        <Button
          type="submit"
          colorScheme="blue"
          size="lg"
          isLoading={loading}
          loadingText="Creating Job..."
        >
          Create Job
        </Button>
      </VStack>
    </form>
  );
}

// Jobs List Component
function JobsList({ 
  jobs, 
  account, 
  onAccept, 
  onComplete, 
  onSettle, 
  onDispute, 
  onView,
  loading,
  showOnlyMine 
}) {
  if (jobs.length === 0) {
    return (
      <Alert status="info">
        <AlertIcon />
        {showOnlyMine ? 'You have no jobs yet' : 'No jobs available'}
      </Alert>
    );
  }

  return (
    <Table variant="simple">
      <Thead>
        <Tr>
          <Th>ID</Th>
          <Th>Status</Th>
          <Th>Payment</Th>
          <Th>Requester</Th>
          <Th>Agent</Th>
          <Th>Created</Th>
          <Th>Actions</Th>
        </Tr>
      </Thead>
      <Tbody>
        {jobs.map((job) => (
          <Tr key={job.id}>
            <Td>{job.id}</Td>
            <Td>
              <Badge colorScheme={statusColors[job.status]}>
                {job.status}
              </Badge>
            </Td>
            <Td>{job.payment} ETH</Td>
            <Td>
              <Text fontSize="sm">
                {job.requester.slice(0, 6)}...{job.requester.slice(-4)}
              </Text>
            </Td>
            <Td>
              {job.agent !== '0x0000000000000000000000000000000000000000' ? (
                <Text fontSize="sm">
                  {job.agent.slice(0, 6)}...{job.agent.slice(-4)}
                </Text>
              ) : (
                <Text fontSize="sm" color="gray.500">-</Text>
              )}
            </Td>
            <Td>
              <Text fontSize="sm">
                {job.createdAt.toLocaleDateString()}
              </Text>
            </Td>
            <Td>
              <HStack spacing={2}>
                <Button size="sm" onClick={() => onView(job)}>
                  View
                </Button>
                
                {job.status === 'Created' && job.requester !== account && (
                  <Button 
                    size="sm" 
                    colorScheme="green"
                    onClick={() => onAccept(job.id)}
                    isLoading={loading}
                  >
                    Accept
                  </Button>
                )}
                
                {job.status === 'Accepted' && job.agent === account && (
                  <Button 
                    size="sm" 
                    colorScheme="blue"
                    onClick={() => {
                      const result = prompt('Enter job result:');
                      if (result) onComplete(job.id, result);
                    }}
                    isLoading={loading}
                  >
                    Complete
                  </Button>
                )}
                
                {job.status === 'Completed' && job.requester === account && (
                  <>
                    <Button 
                      size="sm" 
                      colorScheme="green"
                      onClick={() => onSettle(job.id)}
                      isLoading={loading}
                    >
                      Settle
                    </Button>
                    <Button 
                      size="sm" 
                      colorScheme="red"
                      variant="outline"
                      onClick={() => onDispute(job.id)}
                      isLoading={loading}
                    >
                      Dispute
                    </Button>
                  </>
                )}
              </HStack>
            </Td>
          </Tr>
        ))}
      </Tbody>
    </Table>
  );
}

// Job Details Modal Component
function JobDetailsModal({ isOpen, onClose, job }) {
  if (!job) return null;

  return (
    <Modal isOpen={isOpen} onClose={onClose} size="xl">
      <ModalOverlay />
      <ModalContent>
        <ModalHeader>Job #{job.id} Details</ModalHeader>
        <ModalCloseButton />
        <ModalBody pb={6}>
          <VStack align="stretch" spacing={4}>
            <Box>
              <Text fontWeight="bold">Status</Text>
              <Badge colorScheme={statusColors[job.status]} fontSize="md">
                {job.status}
              </Badge>
            </Box>
            
            <Box>
              <Text fontWeight="bold">Payment</Text>
              <Text>{job.payment} ETH</Text>
            </Box>
            
            <Box>
              <Text fontWeight="bold">Requester</Text>
              <Code>{job.requester}</Code>
            </Box>
            
            {job.agent !== '0x0000000000000000000000000000000000000000' && (
              <Box>
                <Text fontWeight="bold">Agent</Text>
                <Code>{job.agent}</Code>
              </Box>
            )}
            
            <Box>
              <Text fontWeight="bold">Created At</Text>
              <Text>{job.createdAt.toLocaleString()}</Text>
            </Box>
            
            {job.completedAt && (
              <Box>
                <Text fontWeight="bold">Completed At</Text>
                <Text>{job.completedAt.toLocaleString()}</Text>
              </Box>
            )}
            
            <Divider />
            
            <Box>
              <Text fontWeight="bold">Specification</Text>
              <Link href={`${IPFS_GATEWAY}${job.specHash}`} isExternal>
                View on IPFS <ExternalLinkIcon mx="2px" />
              </Link>
              {job.specification && (
                <Code display="block" mt={2} p={2}>
                  {JSON.stringify(job.specification, null, 2)}
                </Code>
              )}
            </Box>
            
            {job.resultHash !== '0x0000000000000000000000000000000000000000000000000000000000000000' && (
              <Box>
                <Text fontWeight="bold">Result</Text>
                <Link href={`${IPFS_GATEWAY}${job.resultHash}`} isExternal>
                  View on IPFS <ExternalLinkIcon mx="2px" />
                </Link>
                {job.result && (
                  <Code display="block" mt={2} p={2}>
                    {JSON.stringify(job.result, null, 2)}
                  </Code>
                )}
              </Box>
            )}
          </VStack>
        </ModalBody>
      </ModalContent>
    </Modal>
  );
}

export default App;
\end{lstlisting}

\section{Comprehensive Testing Suite}
\begin{lstlisting}[language=JavaScript,caption={Complete test suite for smart contracts}]
const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("DeVAA Marketplace", function () {
  let marketplace;
  let owner, requester, agent1, agent2, user;
  let ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
  
  beforeEach(async function () {
    [owner, requester, agent1, agent2, user] = await ethers.getSigners();
    
    const Marketplace = await ethers.getContractFactory("DeVAAMarketplace");
    marketplace = await Marketplace.deploy();
    await marketplace.waitForDeployment();
  });
  
  describe("Deployment", function () {
    it("Should set the right owner", async function () {
      expect(await marketplace.hasRole(await marketplace.DEFAULT_ADMIN_ROLE(), owner.address))
        .to.be.true;
    });
    
    it("Should start with zero jobs", async function () {
      expect(await marketplace.jobCounter()).to.equal(0);
    });
  });
  
  describe("Job Creation", function () {
    it("Should create a job with payment", async function () {
      const payment = ethers.parseEther("1.0");
      const specHash = ethers.keccak256(ethers.toUtf8Bytes("test spec"));
      
      await expect(
        marketplace.connect(requester).createJob(specHash, { value: payment })
      )
        .to.emit(marketplace, "JobCreated")
        .withArgs(0, requester.address, payment, specHash);
      
      const job = await marketplace.jobs(0);
      expect(job.requester).to.equal(requester.address);
      expect(job.payment).to.equal(payment);
      expect(job.specHash).to.equal(specHash);
      expect(job.status).to.equal(0); // Created
    });
    
    it("Should reject job creation without payment", async function () {
      const specHash = ethers.keccak256(ethers.toUtf8Bytes("test spec"));
      
      await expect(
        marketplace.connect(requester).createJob(specHash)
      ).to.be.revertedWith("Payment required");
    });
    
    it("Should track requester jobs", async function () {
      const payment = ethers.parseEther("0.5");
      const specHash = ethers.keccak256(ethers.toUtf8Bytes("spec"));
      
      await marketplace.connect(requester).createJob(specHash, { value: payment });
      await marketplace.connect(requester).createJob(specHash, { value: payment });
      
      const requesterJobs = await marketplace.getRequesterJobs(requester.address);
      expect(requesterJobs.length).to.equal(2);
      expect(requesterJobs[0]).to.equal(0);
      expect(requesterJobs[1]).to.equal(1);
    });
  });
  
  describe("Job Acceptance", function () {
    let jobId;
    const payment = ethers.parseEther("1.0");
    
    beforeEach(async function () {
      const specHash = ethers.keccak256(ethers.toUtf8Bytes("test"));
      await marketplace.connect(requester).createJob(specHash, { value: payment });
      jobId = 0;
    });
    
    it("Should allow agent to accept job", async function () {
      await expect(marketplace.connect(agent1).acceptJob(jobId))
        .to.emit(marketplace, "JobAccepted")
        .withArgs(jobId, agent1.address);
      
      const job = await marketplace.jobs(jobId);
      expect(job.agent).to.equal(agent1.address);
      expect(job.status).to.equal(1); // Accepted
    });
    
    it("Should not allow requester to accept own job", async function () {
      await expect(
        marketplace.connect(requester).acceptJob(jobId)
      ).to.be.revertedWith("Cannot accept own job");
    });
    
    it("Should not allow accepting already accepted job", async function () {
      await marketplace.connect(agent1).acceptJob(jobId);
      
      await expect(
        marketplace.connect(agent2).acceptJob(jobId)
      ).to.be.revertedWith("Job not available");
    });
    
    it("Should track agent jobs", async function () {
      await marketplace.connect(agent1).acceptJob(jobId);
      
      const agentJobs = await marketplace.getAgentJobs(agent1.address);
      expect(agentJobs.length).to.equal(1);
      expect(agentJobs[0]).to.equal(jobId);
    });
  });
  
  describe("Job Completion", function () {
    let jobId;
    const payment = ethers.parseEther("1.0");
    
    beforeEach(async function () {
      const specHash = ethers.keccak256(ethers.toUtf8Bytes("test"));
      await marketplace.connect(requester).createJob(specHash, { value: payment });
      jobId = 0;
      await marketplace.connect(agent1).acceptJob(jobId);
    });
    
    it("Should allow agent to complete job", async function () {
      const resultHash = ethers.keccak256(ethers.toUtf8Bytes("result"));
      const ipfsHash = "QmTest123";
      
      await expect(
        marketplace.connect(agent1).completeJob(jobId, resultHash, ipfsHash)
      )
        .to.emit(marketplace, "JobCompleted")
        .withArgs(jobId, resultHash, ipfsHash);
      
      const job = await marketplace.jobs(jobId);
      expect(job.resultHash).to.equal(resultHash);
      expect(job.status).to.equal(2); // Completed
    });
    
    it("Should only allow assigned agent to complete", async function () {
      const resultHash = ethers.keccak256(ethers.toUtf8Bytes("result"));
      
      await expect(
        marketplace.connect(agent2).completeJob(jobId, resultHash, "ipfs")
      ).to.be.revertedWith("Not the assigned agent");
    });
    
    it("Should not allow completing already completed job", async function () {
      const resultHash = ethers.keccak256(ethers.toUtf8Bytes("result"));
      await marketplace.connect(agent1).completeJob(jobId, resultHash, "ipfs");
      
      await expect(
        marketplace.connect(agent1).completeJob(jobId, resultHash, "ipfs2")
      ).to.be.revertedWith("Invalid job status");
    });
  });
  
  describe("Payment Settlement", function () {
    let jobId;
    const payment = ethers.parseEther("1.0");
    
    beforeEach(async function () {
      const specHash = ethers.keccak256(ethers.toUtf8Bytes("test"));
      await marketplace.connect(requester).createJob(specHash, { value: payment });
      jobId = 0;
      await marketplace.connect(agent1).acceptJob(jobId);
      
      const resultHash = ethers.keccak256(ethers.toUtf8Bytes("result"));
      await marketplace.connect(agent1).completeJob(jobId, resultHash, "ipfs");
    });
    
    it("Should allow requester to settle payment", async function () {
      const agentBalanceBefore = await ethers.provider.getBalance(agent1.address);
      
      await expect(marketplace.connect(requester).settlePayment(jobId))
        .to.emit(marketplace, "JobSettled")
        .withArgs(jobId, agent1.address, payment);
      
      const agentBalanceAfter = await ethers.provider.getBalance(agent1.address);
      expect(agentBalanceAfter - agentBalanceBefore).to.equal(payment);
      
      const job = await marketplace.jobs(jobId);
      expect(job.status).to.equal(3); // Settled
    });
    
    it("Should only allow requester to settle", async function () {
      await expect(
        marketplace.connect(agent1).settlePayment(jobId)
      ).to.be.revertedWith("Only requester can settle");
    });
    
    it("Should not allow settling before completion", async function () {
      // Create new job
      const specHash = ethers.keccak256(ethers.toUtf8Bytes("test2"));
      await marketplace.connect(requester).createJob(specHash, { value: payment });
      const newJobId = 1;
      
      await expect(
        marketplace.connect(requester).settlePayment(newJobId)
      ).to.be.revertedWith("Job not completed");
    });
  });
  
  describe("Dispute Resolution", function () {
    let jobId;
    const payment = ethers.parseEther("1.0");
    
    beforeEach(async function () {
      const specHash = ethers.keccak256(ethers.toUtf8Bytes("test"));
      await marketplace.connect(requester).createJob(specHash, { value: payment });
      jobId = 0;
      await marketplace.connect(agent1).acceptJob(jobId);
      
      const resultHash = ethers.keccak256(ethers.toUtf8Bytes("result"));
      await marketplace.connect(agent1).completeJob(jobId, resultHash, "ipfs");
    });
    
    it("Should allow requester to dispute completed job", async function () {
      await expect(marketplace.connect(requester).disputeJob(jobId))
        .to.emit(marketplace, "JobDisputed")
        .withArgs(jobId, requester.address);
      
      const job = await marketplace.jobs(jobId);
      expect(job.status).to.equal(4); // Disputed
    });
    
    it("Should not allow disputing settled job", async function () {
      await marketplace.connect(requester).settlePayment(jobId);
      
      await expect(
        marketplace.connect(requester).disputeJob(jobId)
      ).to.be.revertedWith("Cannot dispute settled job");
    });
    
    it("Should handle dispute resolution by owner", async function () {
      await marketplace.connect(requester).disputeJob(jobId);
      
      // Owner resolves in favor of agent
      const agentBalanceBefore = await ethers.provider.getBalance(agent1.address);
      
      await expect(
        marketplace.connect(owner).resolveDispute(jobId, true)
      )
        .to.emit(marketplace, "DisputeResolved")
        .withArgs(jobId, true);
      
      const agentBalanceAfter = await ethers.provider.getBalance(agent1.address);
      expect(agentBalanceAfter - agentBalanceBefore).to.equal(payment);
    });
  });
  
  describe("Timeout Handling", function () {
    let jobId;
    const payment = ethers.parseEther("1.0");
    const timeout = 7 * 24 * 60 * 60; // 7 days
    
    beforeEach(async function () {
      const specHash = ethers.keccak256(ethers.toUtf8Bytes("test"));
      await marketplace.connect(requester).createJob(specHash, { value: payment });
      jobId = 0;
      await marketplace.connect(agent1).acceptJob(jobId);
    });
    
    it("Should allow refund if job times out", async function () {
      // Fast forward time
      await time.increase(timeout + 1);
      
      const requesterBalanceBefore = await ethers.provider.getBalance(requester.address);
      
      await expect(marketplace.connect(requester).claimTimeout(jobId))
        .to.emit(marketplace, "JobTimedOut")
        .withArgs(jobId);
      
      const requesterBalanceAfter = await ethers.provider.getBalance(requester.address);
      expect(requesterBalanceAfter).to.be.gt(requesterBalanceBefore);
    });
    
    it("Should not allow timeout claim before period", async function () {
      await expect(
        marketplace.connect(requester).claimTimeout(jobId)
      ).to.be.revertedWith("Timeout period not reached");
    });
  });
  
  describe("Pause Functionality", function () {
    it("Should allow owner to pause contract", async function () {
      await marketplace.connect(owner).pause();
      expect(await marketplace.paused()).to.be.true;
      
      const specHash = ethers.keccak256(ethers.toUtf8Bytes("test"));
      await expect(
        marketplace.connect(requester).createJob(specHash, { value: ethers.parseEther("1") })
      ).to.be.revertedWith("Pausable: paused");
    });
    
    it("Should not allow non-owner to pause", async function () {
      await expect(
        marketplace.connect(requester).pause()
      ).to.be.reverted;
    });
  });
  
  describe("Gas Usage", function () {
    it("Should track gas usage for operations", async function () {
      const payment = ethers.parseEther("0.1");
      const specHash = ethers.keccak256(ethers.toUtf8Bytes("test"));
      
      // Create job
      const createTx = await marketplace.connect(requester).createJob(specHash, { value: payment });
      const createReceipt = await createTx.wait();
      console.log("Create Job Gas:", createReceipt.gasUsed.toString());
      
      // Accept job
      const acceptTx = await marketplace.connect(agent1).acceptJob(0);
      const acceptReceipt = await acceptTx.wait();
      console.log("Accept Job Gas:", acceptReceipt.gasUsed.toString());
      
      // Complete job
      const resultHash = ethers.keccak256(ethers.toUtf8Bytes("result"));
      const completeTx = await marketplace.connect(agent1).completeJob(0, resultHash, "ipfs");
      const completeReceipt = await completeTx.wait();
      console.log("Complete Job Gas:", completeReceipt.gasUsed.toString());
      
      // Settle payment
      const settleTx = await marketplace.connect(requester).settlePayment(0);
      const settleReceipt = await settleTx.wait();
      console.log("Settle Payment Gas:", settleReceipt.gasUsed.toString());
    });
  });
  
  describe("Edge Cases", function () {
    it("Should handle invalid job IDs", async function () {
      await expect(
        marketplace.connect(agent1).acceptJob(999)
      ).to.be.revertedWith("Job does not exist");
    });
    
    it("Should handle zero payment edge case", async function () {
      const specHash = ethers.keccak256(ethers.toUtf8Bytes("free"));
      
      await expect(
        marketplace.connect(requester).createJob(specHash, { value: 0 })
      ).to.be.revertedWith("Payment required");
    });
    
    it("Should handle empty specification hash", async function () {
      await expect(
        marketplace.connect(requester).createJob("0x0000000000000000000000000000000000000000000000000000000000000000", { value: ethers.parseEther("1") })
      ).to.be.revertedWith("Invalid specification");
    });
  });
  
  describe("Integration Scenarios", function () {
    it("Should handle complete job lifecycle", async function () {
      // Setup
      const payment = ethers.parseEther("2.0");
      const specHash = ethers.keccak256(ethers.toUtf8Bytes("integration test"));
      
      // 1. Create job
      await marketplace.connect(requester).createJob(specHash, { value: payment });
      expect(await marketplace.jobCounter()).to.equal(1);
      
      // 2. Agent accepts
      await marketplace.connect(agent1).acceptJob(0);
      let job = await marketplace.jobs(0);
      expect(job.status).to.equal(1);
      
      // 3. Agent completes
      const resultHash = ethers.keccak256(ethers.toUtf8Bytes("integration result"));
      await marketplace.connect(agent1).completeJob(0, resultHash, "QmIntegration");
      job = await marketplace.jobs(0);
      expect(job.status).to.equal(2);
      
      // 4. Requester settles
      await marketplace.connect(requester).settlePayment(0);
      job = await marketplace.jobs(0);
      expect(job.status).to.equal(3);
      
      // Verify final state
      const requesterJobs = await marketplace.getRequesterJobs(requester.address);
      const agentJobs = await marketplace.getAgentJobs(agent1.address);
      expect(requesterJobs.length).to.equal(1);
      expect(agentJobs.length).to.equal(1);
    });
    
    it("Should handle multiple concurrent jobs", async function () {
      const payment = ethers.parseEther("0.5");
      
      // Create multiple jobs
      for (let i = 0; i < 5; i++) {
        const specHash = ethers.keccak256(ethers.toUtf8Bytes(`job ${i}`));
        await marketplace.connect(requester).createJob(specHash, { value: payment });
      }
      
      // Different agents accept different jobs
      await marketplace.connect(agent1).acceptJob(0);
      await marketplace.connect(agent2).acceptJob(1);
      await marketplace.connect(agent1).acceptJob(2);
      await marketplace.connect(agent2).acceptJob(3);
      await marketplace.connect(agent1).acceptJob(4);
      
      // Verify assignments
      expect((await marketplace.jobs(0)).agent).to.equal(agent1.address);
      expect((await marketplace.jobs(1)).agent).to.equal(agent2.address);
      expect((await marketplace.jobs(2)).agent).to.equal(agent1.address);
      expect((await marketplace.jobs(3)).agent).to.equal(agent2.address);
      expect((await marketplace.jobs(4)).agent).to.equal(agent1.address);
      
      // Verify job counts
      expect((await marketplace.getAgentJobs(agent1.address)).length).to.equal(3);
      expect((await marketplace.getAgentJobs(agent2.address)).length).to.equal(2);
    });
  });
});
\end{lstlisting}

\section{Configuration Files}
\begin{lstlisting}[language=JavaScript,caption={package.json - Project dependencies}]
{
  "name": "devaa-mvp",
  "version": "1.0.0",
  "description": "DeVAA - Decentralized and Verifiable AI Agent Marketplace",
  "main": "index.js",
  "scripts": {
    "compile": "hardhat compile",
    "test": "hardhat test",
    "test:coverage": "hardhat coverage",
    "deploy:local": "hardhat run scripts/deploy.js --network localhost",
    "deploy:sepolia": "hardhat run scripts/deploy.js --network sepolia",
    "node": "hardhat node",
    "agent": "cd agent && python agent_runner.py",
    "frontend": "cd frontend && npm run dev",
    "lint": "eslint . --ext .js,.jsx,.ts,.tsx",
    "lint:fix": "eslint . --ext .js,.jsx,.ts,.tsx --fix",
    "format": "prettier --write \"**/*.{js,jsx,ts,tsx,json,sol}\"",
    "verify": "hardhat verify --network sepolia",
    "size": "hardhat size-contracts",
    "gas-report": "REPORT_GAS=true hardhat test",
    "slither": "slither .",
    "mythril": "docker run -v $(pwd):/tmp mythril/myth analyze /tmp/contracts/DeVAAMarketplace.sol",
    "docs": "hardhat docgen"
  },
  "keywords": [
    "blockchain",
    "ethereum",
    "ai",
    "agents",
    "marketplace",
    "decentralized"
  ],
  "author": "DeVAA Team",
  "license": "MIT",
  "devDependencies": {
    "@nomicfoundation/hardhat-chai-matchers": "^2.0.0",
    "@nomicfoundation/hardhat-ethers": "^3.0.0",
    "@nomicfoundation/hardhat-network-helpers": "^1.0.0",
    "@nomicfoundation/hardhat-toolbox": "^3.0.0",
    "@nomicfoundation/hardhat-verify": "^1.0.0",
    "@nomiclabs/hardhat-etherscan": "^3.1.7",
    "@typechain/ethers-v6": "^0.4.0",
    "@typechain/hardhat": "^8.0.0",
    "@types/chai": "^4.2.0",
    "@types/mocha": ">=9.1.0",
    "@types/node": ">=16.0.0",
    "chai": "^4.2.0",
    "eslint": "^8.0.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^5.0.0",
    "ethers": "^6.4.0",
    "hardhat": "^2.17.0",
    "hardhat-contract-sizer": "^2.10.0",
    "hardhat-gas-reporter": "^1.0.9",
    "prettier": "^3.0.0",
    "prettier-plugin-solidity": "^1.1.3",
    "solidity-coverage": "^0.8.0",
    "typechain": "^8.3.0"
  },
  "dependencies": {
    "@openzeppelin/contracts": "^4.9.3",
    "dotenv": "^16.3.1"
  }
}
\end{lstlisting}

\begin{lstlisting}[language=JavaScript,caption={.env.example - Environment variables template}]
# Ethereum Network Configuration
SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/9aa3d95b3bc440fa88ea...
MAINNET_RPC_URL=https://mainnet.infura.io/v3/9aa3d95b3bc440fa88ea...

# Private Keys (NEVER commit real keys!)
DEPLOYER_PRIVATE_KEY=0x0000000000000000000000000000000000000000000000000000000000000000
AGENT_PRIVATE_KEY=0x0000000000000000000000000000000000000000000000000000000000000000

# Contract Addresses (populated after deployment)
MARKETPLACE_CONTRACT_ADDRESS=
VERIFIER_CONTRACT_ADDRESS=

# IPFS Configuration
IPFS_API_URL=http://localhost:5001
IPFS_GATEWAY_URL=https://ipfs.io/ipfs/

# Agent Configuration
MAX_CONCURRENT_JOBS=10
MIN_JOB_PAYMENT_ETH=0.01
GAS_PRICE_MULTIPLIER=1.2
AGENT_API_PORT=8080

# Frontend Configuration
VITE_CONTRACT_ADDRESS=
VITE_CHAIN_ID=11155111
VITE_RPC_URL=https://sepolia.infura.io/v3/9aa3d95b3bc440fa88ea...
VITE_IPFS_GATEWAY=https://ipfs.io/ipfs/

# Monitoring and Analytics
PROMETHEUS_ENDPOINT=http://localhost:9090
GRAFANA_API_KEY=

# External APIs (if needed)
ETHERSCAN_API_KEY=PSB8C9XL6YQ8MQ8M7T...
COINMARKETCAP_API_KEY=b54bcf4d-1bca-4e8e-9a24...

# Redis Configuration (for agent caching)
REDIS_URL=redis://localhost:6379

# Logging
LOG_LEVEL=info
LOG_FILE_PATH=./logs/devaa.log
\end{lstlisting}

\begin{lstlisting}[language=JavaScript,caption={docker-compose.yml - Development environment}]
version: '3.8'

services:
  # Local Ethereum node
  hardhat:
    build:
      context: .
      dockerfile: docker/hardhat.Dockerfile
    ports:
      - "8545:8545"
    volumes:
      - ./contracts:/app/contracts
      - ./scripts:/app/scripts
      - ./test:/app/test
    command: npx hardhat node
    networks:
      - devaa-network

  # IPFS node
  ipfs:
    image: ipfs/go-ipfs:latest
    ports:
      - "4001:4001"
      - "5001:5001"
      - "8080:8080"
    volumes:
      - ipfs-data:/data/ipfs
    environment:
      - IPFS_PROFILE=server
    networks:
      - devaa-network

  # Redis for caching
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    networks:
      - devaa-network

  # Agent runner
  agent:
    build:
      context: ./agent
      dockerfile: Dockerfile
    depends_on:
      - hardhat
      - ipfs
      - redis
    environment:
      - RPC_URL=http://hardhat:8545
      - IPFS_API=http://ipfs:5001
      - REDIS_URL=redis://redis:6379
    env_file:
      - .env
    ports:
      - "8081:8080"
    volumes:
      - ./agent:/app
    networks:
      - devaa-network

  # Frontend
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    depends_on:
      - hardhat
    ports:
      - "3000:3000"
    environment:
      - VITE_RPC_URL=http://localhost:8545
      - VITE_CHAIN_ID=31337
    volumes:
      - ./frontend:/app
      - /app/node_modules
    networks:
      - devaa-network

  # Prometheus for metrics
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus-data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
    networks:
      - devaa-network

  # Grafana for visualization
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3001:3000"
    volumes:
      - ./monitoring/grafana:/etc/grafana/provisioning
      - grafana-data:/var/lib/grafana
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
      - GF_USERS_ALLOW_SIGN_UP=false
    networks:
      - devaa-network

volumes:
  ipfs-data:
  redis-data:
  prometheus-data:
  grafana-data:

networks:
  devaa-network:
    driver: bridge
\end{lstlisting}

\section{Zero-Knowledge Proof Integration}
\begin{lstlisting}[language=JavaScript,caption={circuits/wordcount.circom - ZK circuit for word count verification}]
pragma circom 2.0.0;

include "../node_modules/circomlib/circuits/comparators.circom";
include "../node_modules/circomlib/circuits/gates.circom";

template CharacterCounter() {
    signal input text[1000]; // Max 1000 characters
    signal input length;
    signal output wordCount;
    signal output charCount;
    
    // Count spaces to determine words
    component isSpace[1000];
    component isNewline[1000];
    component isTab[1000];
    component isWhitespace[1000];
    
    signal spaceCount;
    signal intermediateSpaceSum[1000];
    
    intermediateSpaceSum[0] <== 0;
    
    for (var i = 0; i < 1000; i++) {
        // Check if character is space (32)
        isSpace[i] = IsEqual();
        isSpace[i].in[0] <== text[i];
        isSpace[i].in[1] <== 32;
        
        // Check if character is newline (10)
        isNewline[i] = IsEqual();
        isNewline[i].in[0] <== text[i];
        isNewline[i].in[1] <== 10;
        
        // Check if character is tab (9)
        isTab[i] = IsEqual();
        isTab[i].in[0] <== text[i];
        isTab[i].in[1] <== 9;
        
        // Combine whitespace checks
        isWhitespace[i] = OR();
        isWhitespace[i].a <== isSpace[i].out;
        isWhitespace[i].b <== isNewline[i].out + isTab[i].out;
        
        // Accumulate space count
        if (i > 0) {
            intermediateSpaceSum[i] <== intermediateSpaceSum[i-1] + isWhitespace[i].out;
        }
    }
    
    spaceCount <== intermediateSpaceSum[999];
    
    // Word count is approximately space count + 1
    // (assuming well-formed text)
    wordCount <== spaceCount + 1;
    
    // Character count is the provided length
    charCount <== length;
}

template WordCountVerifier() {
    signal input text[1000];
    signal input length;
    signal input claimedWordCount;
    signal input claimedCharCount;
    
    component counter = CharacterCounter();
    counter.text <== text;
    counter.length <== length;
    
    // Verify claims match computed values
    component wordCheck = IsEqual();
    wordCheck.in[0] <== counter.wordCount;
    wordCheck.in[1] <== claimedWordCount;
    
    component charCheck = IsEqual();
    charCheck.in[0] <== counter.charCount;
    charCheck.in[1] <== claimedCharCount;
    
    // Both checks must pass
    signal output valid;
    valid <== wordCheck.out * charCheck.out;
}

component main = WordCountVerifier();
\end{lstlisting}
